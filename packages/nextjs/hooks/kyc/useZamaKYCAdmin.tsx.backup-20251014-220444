"use client";

import { useState, useEffect, useCallback } from "react";
import { useDeployedContractInfo } from "../helper";
import { useWagmiEthers } from "../wagmi/useWagmiEthers";
import { ethers } from "ethers";

interface PendingApp {
  user: string;
  nameHash: string;
  addressHash: string;
  documentHash: string;
  submittedAt: number;
}

export const useZamaKYCAdmin = (parameters: {
  initialMockChains?: Readonly<Record<number, string>>;
}) => {
  const { initialMockChains } = parameters;
  const { chainId, accounts, isConnected, ethersReadonlyProvider, ethersSigner } = useWagmiEthers(initialMockChains);
  const [pendingApplications, setPendingApplications] = useState<PendingApp[]>([]);
  const [isProcessing, setIsProcessing] = useState(false);
  const [message, setMessage] = useState("");
  const [refreshTrigger, setRefreshTrigger] = useState(0);
  const zamaKYC = useDeployedContractInfo("ZamaKYC");

  const getContract = (mode: "read" | "write") => {
    if (!zamaKYC?.data) return undefined;
    const providerOrSigner = mode === "read" ? ethersReadonlyProvider : ethersSigner;
    if (!providerOrSigner) return undefined;
    return new ethers.Contract(zamaKYC.data.address, zamaKYC.data.abi as any, providerOrSigner);
  };

  // Fetch pending applications from events (10 block loop)
  useEffect(() => {
    const fetchPending = async () => {
      if (!ethersReadonlyProvider || !zamaKYC?.data) return;
      try {
        const contract = getContract("read");
        if (!contract) return;
        console.log("üîç Fetching KYC events... (refresh:", refreshTrigger, ")");

        const latestBlock = await ethersReadonlyProvider.getBlockNumber();
        const startBlock = Math.max(0, latestBlock - 10000); // Son 10000 blok
        const step = 10; // 10 blokluk par√ßa
        
        const allEvents: any[] = [];
        for (let fromBlock = startBlock; fromBlock <= latestBlock; fromBlock += step) {
          const toBlock = Math.min(fromBlock + step - 1, latestBlock);
          try {
            const events = await contract.queryFilter(contract.filters.KYCSubmitted(), fromBlock, toBlock);
            allEvents.push(...events);
          } catch (e) {
            console.warn(`Block ${fromBlock}-${toBlock} query error:`, e);
          }
        }

        console.log(`üì¨ Found ${allEvents.length} total submissions`);

        const pendingMap = new Map<string, PendingApp>();
        for (const event of allEvents) {
          if (!("args" in event)) continue;
          const userAddress = event.args.user || event.args.realtor || event.args[0] as string;
          try {
            const data = await contract.getKYCData(userAddress);
            const status = Number(data[3]);
            console.log(`üë§ ${userAddress.slice(0, 8)}: status=${status}`);
            if (status === 1) {
              pendingMap.set(userAddress, {
                user: userAddress,
                nameHash: data[0].toString(),
                addressHash: data[1].toString(),
                documentHash: data[2].toString(),
                submittedAt: Number(data[4]),
              });
            }
          } catch (err) {
            console.log(`‚ö†Ô∏è Error checking ${userAddress}:`, err);
          }
        }

        const pending = Array.from(pendingMap.values());
        console.log(`‚úÖ Found ${pending.length} unique pending applications`);
        setPendingApplications(pending);
      } catch (error) {
        console.error("Error fetching pending:", error);
      }
    };
    fetchPending();
  }, [ethersReadonlyProvider, zamaKYC?.data, refreshTrigger]);

  const approveKYC = useCallback(
    async (applicant: string) => {
      if (!ethersSigner) return;
      setIsProcessing(true);
      setMessage("Approving KYC...");
      try {
        const writeContract = getContract("write");
        if (!writeContract) {
          setMessage("Contract not available");
          return;
        }
        const tx = await writeContract.approveKYC(applicant);
        setMessage("Waiting for confirmation...");
        await tx.wait();
        setMessage("‚úÖ KYC approved successfully!");
        setTimeout(() => setRefreshTrigger(prev => prev + 1), 1000);
      } catch (e: any) {
        console.error("Approval error:", e);
        setMessage(`‚ùå Approval failed: ${e?.message || String(e)}`);
      } finally {
        setIsProcessing(false);
      }
    },
    [ethersSigner],
  );

  const rejectKYC = useCallback(
    async (applicant: string, reason: string) => {
      if (!ethersSigner) return;
      setIsProcessing(true);
      setMessage("Rejecting KYC...");
      try {
        const writeContract = getContract("write");
        if (!writeContract) {
          setMessage("Contract not available");
          return;
        }
        const tx = await writeContract.rejectKYC(applicant, reason);
        setMessage("Waiting for confirmation...");
        await tx.wait();
        setMessage("‚úÖ KYC rejected successfully!");
        setTimeout(() => setRefreshTrigger(prev => prev + 1), 1000);
      } catch (e: any) {
        console.error("Rejection error:", e);
        setMessage(`‚ùå Rejection failed: ${e?.message || String(e)}`);
      } finally {
        setIsProcessing(false);
      }
    },
    [ethersSigner],
  );

  const refreshPendingList = useCallback(() => {
    setRefreshTrigger(prev => prev + 1);
  }, []);

  return {
    pendingApplications,
    approveKYC,
    rejectKYC,
    refreshPendingList,
    message,
    isProcessing,
    chainId,
    accounts,
    isConnected,
  };
};
